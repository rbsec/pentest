#!/usr/bin/env python3
#
# Test a file of john rules and sort them by effectiveness
# Runs a wordlist attack with each rule and sorts by passwords cracked/second
# Can optionally be used in a cumulative mode to remove overlapping/duplicate rules
#

import re
import os
import subprocess
import sys
import datetime

class col:
    if sys.stdout.isatty():
        green = '\033[32m'
        blue = '\033[94m'
        red = '\033[31m'
        brown = '\033[33m'
        end = '\033[0m'
    else:   # Colours mess up redirected output, disable them
        green = ""
        blue = ""
        red = ""
        brown = ""
        end = ""

# Run a shell command and return output
def runcmd(cmd):
    devnull = open(os.devnull, 'w')
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=devnull, shell=True)
    return proc.stdout.read()

def getcrackedcount():
    # You may need to change the hash path here
    joutput = runcmd("john --format=nt --show --pot=rtest.pot " + hashfile)
    lastline = joutput.splitlines()[-1]
    m = re.search('^\d+', lastline.decode())
    count = int(m.group(0))
    return count

def test_rule(jrule, wordlist, hashfile):
    start = datetime.datetime.now()
    # You may need to change the hash path here
    joutput = runcmd("john --format=nt --session=rtest --pot=rtest.pot " + hashfile \
            + " --wordlist=" + wordlist + " --rules=:" + jrule + " --max-run-time=300")
    elapsed = datetime.datetime.now()
    delta = elapsed - start
    return delta.total_seconds()

def remove_pot():
    try:
        os.remove("rtest.pot")
    except OSError:
        pass

def getrules(rulefile):
    with open(rulefile) as f:
        rules = []
        lines = f.readlines()
        for line in lines:
            line = line.rstrip()
            # Ignore comments and rule section headings
            if line.startswith('#') or line.startswith('[List.Rules') or line == '':
                continue
            rules.append(line)
    return rules

if len(sys.argv) < 5:
    print("Usage: ruletest.py <rulefile> <hashfile> <wordlist> <output_file> [cumulative]\n\n")
    sys.exit(1)

rulefile = sys.argv[1]
hashfile = sys.argv[2]
wordlist = sys.argv[3]
outfile = sys.argv[4]
if len(sys.argv) > 5:
    cumulative = 1
else:
    cumulative = 0

crackrate = {}

rules = getrules(rulefile)
rulecount = len(rules)
i = 1
# remove_pot()

for rule in rules:
    try:
        # If you want to do non-cumulative testing with an existing pot, use this
        # os.system("cp pot.main.dnwordlist rtest.pot")
        if cumulative:
            count_before = getcrackedcount()
        jrule = "'" + rule.replace("'", "\\'") + "'"
        elapsed = test_rule(jrule, wordlist, hashfile)
        count = getcrackedcount()
        if cumulative:
            count = count - count_before
        rate = count / elapsed
        crackrate[rule] = rate
        print("[" + col.blue + str(i) + col.end + "/" + str(rulecount) + "] Rule "
                + col.brown + rule + col.end + " cracked " + col.green + str(count) + col.end
                + " passwords " + "in " + col.blue + str(round(elapsed,2)) + col.end + " seconds ("
                + col.green + str(round(rate,2)) + col.end + " passwords/second)")
        if not cumulative:
             remove_pot()
        i += 1
    except KeyboardInterrupt:
        print("Caught keyboard interrupt, exiting.\n")
        break
os.remove('rtest.log')

with open(outfile, "w") as f:
    f.write("# Ruletest for wordlist " + wordlist + "\n")
    for rule in sorted(crackrate, key=crackrate.get, reverse=True):
        rate = str(round(crackrate[rule], 2))
        print (rule.ljust(80) + "# " + rate)
        f.write(rule.ljust(80) + "# " + rate + "\n")
