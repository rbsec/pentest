#!/usr/bin/env python3

# Test a file of john rules and sort them by effectiveness
# Runs a wordlist attack with each rule and sorts by passwords cracked/second
# Can optionally be used in a cumulative mode to remove overlapping/duplicate rules

# Usage: $ rule_test.py <hashfile> <wordlist> <rulefile> <output_file> [cumulative]

import re
import os
import subprocess
import sys
import datetime

class col:
    if sys.stdout.isatty():
        green = '\033[32m'
        blue = '\033[94m'
        red = '\033[31m'
        brown = '\033[33m'
        end = '\033[0m'
    else:   # Colours mess up redirected output, disable them
        green = ""
        blue = ""
        red = ""
        brown = ""
        end = ""

# Run a shell command and return output
def runcmd(cmd):
    devnull = open(os.devnull, 'w')
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=devnull, shell=True)
    return proc.stdout.read()

def getcrackedcount():
    joutput = runcmd(f"john --format=nt --show --pot=rtest.pot {hashfile}").decode('utf-8')
    lastline = joutput.splitlines()[-1]
    m = re.search('^\d+', lastline)
    count = int(m.group(0))
    return count

def test_rule(jrule, wordlist):
    start = datetime.datetime.now()
    joutput = runcmd(f"john --format=nt --session=rtest --pot=rtest.pot {hashfile}"
                     f" --wordlist={wordlist} --rules=:{jrule} --max-run-time=300")
    elapsed = datetime.datetime.now()
    delta = elapsed - start
    return delta.total_seconds()

def cleanup_files():
    try:
        os.remove("rtest.pot")
        os.remove("rtest.log")
        os.remove("rtest.rec")
    except OSError:
        pass

def getrules(rulefile):
    with open(rulefile) as f:
        rules = []
        lines = f.readlines()
        for line in lines:
            line = line.rstrip()
            # Ignore comments and rule section headings
            if line.startswith('#') or line.startswith('[List.Rules') or line.startswith('.include') or line == '':
                continue
            rules.append(line)
    return rules

if len(sys.argv) < 5:
    print(f"{col.red}Usage: {sys.argv[0]} <hashfile> <wordlist> <rulefile> <output_file> [cumulative]{col.end}")
    sys.exit(1)

hashfile = sys.argv[1]
rulefile = sys.argv[3]
wordlist = sys.argv[2]
outfile = sys.argv[4]
if len(sys.argv) > 5:
    cumulative = 1
else:
    cumulative = 0

crackrate = {}

rules = getrules(rulefile)
rulecount = len(rules)
i = 1
cleanup_files()

for rule in rules:
    try:
        if cumulative:
            count_before = getcrackedcount()
        jrule = "'" + rule.replace("'", "\\'") + "'"
        elapsed = test_rule(jrule, wordlist)
        count = getcrackedcount()
        if cumulative:
            count = count - count_before
        rate = count / elapsed
        crackrate[rule] = rate
        print(f"[{col.blue}{str(i)}{col.end}/{str(rulecount)}] Rule {col.brown}{rule}{col.end}"
              f" cracked {col.green}{str(count)}{col.end} passwords in {col.blue} {str(round(elapsed,2))}{col.end}"
              f" seconds ({col.green}{str(round(rate,2))}{col.end} passwords/second)")
        if not cumulative:
             cleanup_files()
        i += 1
    except KeyboardInterrupt:
        print("Caught keyboard interrupt, exiting.\n")
        break
cleanup_files()

with open(outfile, "w") as f:
    f.write(f"# Rule test for wordlist {wordlist}\n")
    for rule in sorted(crackrate, key=crackrate.get, reverse=True):
        rate = str(round(crackrate[rule], 2))
        print (f"{rule.ljust(80)} # {rate}")
        f.write(f"{rule}\n")
